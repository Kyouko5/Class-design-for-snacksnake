# 软件基础课设
## 一、贪吃蛇
### 设计思路：

#### 1.游戏规则实现：

- 蛇的生成与移动：生成一条初始长度的蛇，并支持方向控制（上下左右移动）。
- 食物生成：随机生成食物，蛇吃到食物后自身长度增加，同时生成新的食物
- 碰撞检测：当蛇碰到墙壁或自身时，游戏结束。
- 得分系统：每吃到一个食物，得分增加，**根据要求可以显示总分数。**

#### 2.用户界面：

- 游戏界面：用网格表示游戏区域，蛇和食物使用简单的颜色或图案区分。
- 得分显示：在界面上实时显示得分。
- 游戏结束提示：当游戏结束时，显示总分数及重玩选项。
- 左侧设计一个控制栏，展示游戏参数选项

#### 3.游戏难度：

- 速度控制：
    - 可以自由设置蛇的速度
    - 添加蛇的长度越长速度越快的难度设置
- 关卡设计：
    - 增加障碍物，如墙

#### 4.开发环境和语言：

- 这里我选择编写一个网站实现，一方面是便于用户界面的设计，另一方面是正好和这学期的课进行组合
- 使用HTML和CSS设计用户界面，JavaScript实现内部逻辑

#### 5.功能扩展：

- 特殊食物：
    - 加入特殊食物，赋予蛇临时加速、缩短、减速等效果
- AI控制：
    - 增加AI控制的蛇，或实现双人对战

#### 为了实现 AI 蛇的避障功能，使其能够避开自身身体和障碍物，采用路径规划算法 A* 算法，来计算一条安全路径。

#### 实现思路

1. **定义网格和节点**：将整个游戏区域划分为网格，每个网格单元（节点）记录 AI 蛇能否通行。
2. **A\* 路径规划**：使用 A* 算法寻找从当前蛇头位置到目标位置（例如食物）的最短路径，同时确保路径避开蛇身体和障碍。
3. **避开身体和障碍**：在路径规划时，将蛇身体和墙壁标记为“不可通行”节点，避免 AI 碰撞。
4. **动态更新路径**：当路径被阻挡（例如蛇身体移动到路径上）时，重新计算路径。



## A*记录总结

- 对于A*算法，其实就是在Dijkstra算法的基础上，简单的添加了一个`启发函数`**（在逻辑上实际只影响了主循环最开始从待访问节点中获取最优先节点）**，使得每次在遍历更新最短路径的时候，**会优先朝着目标点进行更新**，而不是向四周遍历。

事实上在代码中，

- 将dijkstra中的`dist`，也就是起点到每个点的最短距离，变成了`gScore`
- 将优先权队列改成了开放列表（其实就是改了个名字）优先权队列中是以`{节点， 权值}`存放，

       开放列表是只存放了`{节点x， 节点y}`,将权值拆分出来

- 在取出节点作为current的时候，A*使用 `G 值（起点到当前点的实际代价）+ H 值（当前点到目标的估计代价）`作为用于决定优先搜索的节点的参数。
- `if (tentative_gScore < gScore[neighbor.x][neighbor.y]
    || !closedSet.some(node => node.x === neighbor.x && node.y === neighbor.y))`

      这一段为是否要更新的条件 1、如果该节点还没被访问；2、如果新路径更加短

至于为什么使用g值来作为路径判定，因为是建立在Djikstra算法的基础上，要保证最终得到的是最短路径
            

- 在更新邻居节点中，添加了更新fScore的操作